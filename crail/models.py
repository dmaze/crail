"""Database object models.

.. Copyright Â© 2015, David Maze

These are :mod:`sqlalchemy` declarative object models.  Most of the
class-scoped fields are translated into instance fields that are read
and written to the underlying database.

>>> from crail.models import db, Player
>>> player = Player.query.get(id=1)
>>> player.money
10
>>> player.money = 20
>>> db.session.commit()

.. autodata:: db
.. autodata:: migrate
.. autoclass:: Good
   :members:
.. autoclass:: City
   :members:
.. autoclass:: Contract
   :members:
.. autoclass:: Card
   :members:
.. autoclass:: World
   :members:
.. autoclass:: Player
   :members:
.. autoclass:: PlayedCard
   :members:
.. autoclass:: Game
   :members:

"""
from flask.ext.migrate import Migrate
from flask.ext.sqlalchemy import SQLAlchemy

#: The Flask-SQLAlchemy bridge object.
db = SQLAlchemy()

# Get better autogenerated names for things
db.metadata.naming_convention = {
    "ix": 'ix_%(column_0_label)s',
    "uq": "uq_%(table_name)s_%(column_0_name)s",
    "ck": "ck_%(table_name)s_%(constraint_name)s",
    "fk": "fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s",
    "pk": "pk_%(table_name)s"
}

#: The Flask-Migrate Alembic wrapper.
migrate = Migrate(db=db)


class Good(db.Model):
    """A single good.

    This is an object representation of, for instance, "coal".  It is not
    scoped to a world.

    .. attribute:: producers

       List of :class:`City` that produce this good (in all worlds).

    .. attribute:: contracts

       List of :class:`Contract` to deliver this good.
    """
    #: Integer identifier of this good.
    id = db.Column(db.Integer, db.Sequence('good_id_seq'), primary_key=True)

    #: Name of this good.
    name = db.Column(db.String(32), unique=True)

    def __str__(self):
        return self.name

    def __repr__(self):
        return 'Good(id={0.id!r}, name={0.name!r})'.format(self)


#: Many-to-many join table recording which cities produce which goods.
city_produces = db.Table(
    'city_produces', db.metadata,
    db.Column('good_id', db.Integer, db.ForeignKey('good.id'), nullable=False),
    db.Column('city_id', db.Integer, db.ForeignKey('city.id'), nullable=False)
)


class City(db.Model):
    """A single city.

    .. attribute:: contracts

       List of :class:`Contract` that deliver to this city.

    """
    #: Integer identifier of this city.
    id = db.Column(db.Integer, db.Sequence('city_id_seq'), primary_key=True)

    #: Name of this city.
    name = db.Column(db.String(64), nullable=False)

    #: List of :class:`Good` this city produces.
    produces = db.relationship('Good', secondary=city_produces,
                               backref='producers')

    #: Integer identifier of :attr:`world`.
    world_id = db.Column(db.Integer, db.ForeignKey('world.id'), nullable=False)

    #: World in which this city exists.
    world = db.relationship('World', backref=db.backref('cities'))

    def __str__(self):
        return self.name

    def __repr__(self):
        return ('City(id={0.id!r}, name={0.name!r}, produces={0.produces!r}, '
                'world={0.world!r})'.format(self))


class Contract(db.Model):
    """A single contract on a contract card.

    This is a contract to deliver :attr:`good` to :attr:`city` for
    :attr:`amount`.  This does not specifically exist in a world, but
    both its :attr:`cards` and its :attr:`city` do, and these worlds
    should match.

    .. attribute:: cards

       List of :class:`Card` on which this contract appears.

    .. todo::

       :attr:`cards` is likely to change to a one-to-many relationship,
       where a contract lives on a single :class:`Card`.

    """
    #: Integer identifier of this contract.
    id = db.Column(db.Integer, db.Sequence('contract_id_seq'),
                   primary_key=True)

    #: Integer identifier of :attr:`good`.
    good_id = db.Column(db.Integer, db.ForeignKey('good.id'), nullable=False)

    #: :class:`Good` to deliver.
    good = db.relationship('Good', backref=db.backref('contracts'))

    #: Integer identifier of :attr:`city`.
    city_id = db.Column(db.Integer, db.ForeignKey('city.id'), nullable=False)

    #: :class:`City` destination.
    city = db.relationship('City', backref=db.backref('contracts'))

    #: Integer amount the contract is worth.
    amount = db.Column(db.Integer, nullable=False)

    def __str__(self):
        return '{0.good!s} to {0.city!s} for {0.amount}'.format(self)

    def __repr__(self):
        return ('Contract(id={0.id!r}, good={0.good!r}, city={0.city!r}, '
                'amount={0.amount!r})'.format(self))


#: Many-to-many table binding :class:`Card` to :class:`Contract`.
card_contract = db.Table(
    'card_contract', db.metadata,
    db.Column('card_id', db.Integer, db.ForeignKey('card.id'), nullable=False),
    db.Column('contract_id', db.Integer, db.ForeignKey('contract.id'),
              nullable=False)
)


class Card(db.Model):
    """A single card.

    Canonically a card is either an event card (with no contracts) or
    a contract card (with exactly three contracts and no event).  This
    is not enforced in this schema.

    .. attribute:: players

       List of :class:`Player` holding this card (in all currently
       running games).

    .. attribute:: played_cards

       List of :class:`PlayedCard` indicating that the card has been
       discarded in some game.

    """

    #: Integer identifier of the card.
    id = db.Column(db.Integer, db.Sequence('card_id_seq'), primary_key=True)

    #: Printed number on the card.
    #: If :const:`None` this is an auto-generated card.
    number = db.Column(db.Integer)

    #: If this is an event card, text of the event.
    event = db.Column(db.Text)

    #: List of :class:`Contract` objects on this card.
    contracts = db.relationship('Contract', secondary=card_contract,
                                backref='cards')

    #: Integer identifier of :attr:`world`
    world_id = db.Column(db.Integer, db.ForeignKey('world.id'), nullable=False)

    #: :class:`World` in which this card exists
    world = db.relationship('World', backref=db.backref('cards'))

    def __str__(self):
        text = 'Card {0.number!s}: '.format(self)
        if self.event:
            text += self.event
            if self.contracts:
                text += '; '
        if self.contracts:
            text += '; '.join(str(c) for c in self.contracts)
        if not (self.event or self.contracts):
            text += 'Blank'
        return text

    def __repr__(self):
        return ('Card(id={0.id!r}, event={0.event!r}, '
                'contracts={0.contracts!r}, world={0.world!r}'.format(self))


class World(db.Model):
    """Information about a printed board game.

    This does not vary from game session to game session.  Most
    crayon-rails games are not on "other worlds" in the traditional
    sense (with the exceptions of *Lunar Rails* and *Martian Rails*)
    but this still seems like convenient terminology.

    .. attribute:: cities

       List of :class:`City` in this world.

    .. attribute:: cards

       List of :class:`Card` in this world.

    """
    #: Integer identifier of the world.
    id = db.Column(db.Integer, db.Sequence('world_id_seq'), primary_key=True)

    #: The name of the world; what is printed on the box.
    name = db.Column(db.String(64), unique=True)

    def __str__(self):
        return self.name

    def __repr__(self):
        return 'World(id={0.id!r}, name={0.name!r})'.format(self)


#: Many-to-many join table indicating which players hold which cards.
player_card = db.Table(
    'player_card', db.metadata,
    db.Column('player_id', db.Integer, db.ForeignKey('player.id'),
              nullable=False),
    db.Column('card_id', db.Integer, db.ForeignKey('card.id'), nullable=False)
)


class Player(db.Model):
    """State for a single player.

    .. todo::

       This object conflates "who is the player" and "what is the player's
       state in the game".  To leave a game and join a new one, you in
       effect need to discard all of your cards, spend all of your money,
       and plan to never return.  The player-game state should be split out.

    """
    #: Integer identifier of the player.
    id = db.Column(db.Integer, db.Sequence('player_id_seq'), primary_key=True)

    #: Name of the player; what they typed as their login name.
    name = db.Column(db.Text, nullable=False)

    #: Amount of money this player holds.
    money = db.Column(db.Integer, nullable=False)

    #: List of :class:`Card` this player holds.
    cards = db.relationship('Card', secondary=player_card,
                            backref=db.backref('players'))

    #: Integer identifier of :attr:`game`.
    game_id = db.Column(db.Integer, db.ForeignKey('game.id'))

    #: :class:`Game` the player is currently playing.
    game = db.relationship('Game', backref=db.backref('players'))

    def __str__(self):
        return self.name

    def __repr__(self):
        return ('Player(id={0.id!r}, name={0.name!r}, money={0.money!r}, '
                'cards={0.cards!r}, game={0.game!r})'.format(self))


class PlayedCard(db.Model):
    """Record that a card has been played in a game."""
    #: Integer identifier of the record.
    id = db.Column(db.Integer, db.Sequence('played_card_seq'),
                   primary_key=True)

    #: Integer identifier of :attr:`game`.
    game_id = db.Column(db.Integer, db.ForeignKey('game.id'), nullable=False)

    #: :class:`Game` in which the card was played.
    game = db.relationship('Game', backref=db.backref('played_cards'))

    #: Integer identifier of :attr:`card`.
    card_id = db.Column(db.Integer, db.ForeignKey('card.id'), nullable=False)

    #: :class:`Card` that was played.
    card = db.relationship('Card', backref=db.backref('played_cards'))

    def __repr__(self):
        return ('PlayedCard(id={0.id!r}, game={0.game!r}, card={0.card!r})'
                .format(self))


class Game(db.Model):
    """A running game session.

    .. attribute:: players

       List of :class:`Player` playing the game.

    .. attribute:: played_cards

       List of :class:`PlayedCard` indicating which cards have been
       discarded during the game.

    """
    #: Integer identifier of the game.
    id = db.Column(db.Integer, db.Sequence('game_id_seq'), primary_key=True)

    #: Integer identifier of `world`.
    world_id = db.Column(db.Integer, db.ForeignKey('world.id'), nullable=False)

    #: :class:`World` in which the game takes place.
    world = db.relationship('World')

    def __str__(self):
        return 'Game {0.id} ({0.world.name})'.format(self)

    def __repr__(self):
        return 'Game(id={0.id!r}, world={0.world!r})'.format(self)
